# Triangle
## Description:
```
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
```
### For example:
```
 given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
```
### Note:
```
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 
```
```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int high=triangle.size();
        vector<vector<int>> dp(high,vector<int>(high));
        for(int i=0;i<high;i++)
            dp[i].resize(i+1);
        dp[0][0]=triangle[0][0];
        for(int i=1;i<high;i++)
        {
            dp[i][0]=dp[i-1][0]+triangle[i][0];
            for(int j=1;j<i;j++)
                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];
            dp[i][i]=dp[i-1][i-1]+triangle[i][i];
        }
        int answer=dp[high-1][0];
        for(int i=1;i<high;i++)
            answer=min(answer,dp[high-1][i]);
        return answer;
    }
};
```
********************************
一道典型的动态规划问题。我的方法是定义一个与给定数组一样的二维数组dp，然后可以把它分成这些子文题：

1. 初始状态：dp[0][0]=triangle[0][0];
2. 状态转移：
   
    1. 每行第一个：dp[i][0]=dp[i-1][0]+triangle[i][0].因为triangle[i][0]只能从triangle[i-1][0]走到；
    
    2. 每行第二个至倒数第二个：dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]。此时每一个都有两条路可以走到，我们取较小者即可；
    3. 每行最后一个：dp[i][i]=dp[i-1][i-1]+triangle[i][i]。理由跟第一个一样。

3. 在最后一行中找到最小值者并返回。

思路如上，在用代码来实现即可。   