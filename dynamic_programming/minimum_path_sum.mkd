#Minimum Path Sum
##Description:
```
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
```
###Note:
 You can only move either down or right at any point in time.

###Example 1:
```
[[1,3,1],
 [1,5,1],
 [4,2,1]]

Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
```
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int row=grid.size(),col=grid[0].size();
        vector<vector<int>> dp(row,vector<int>(col));
        dp[0][0]=grid[0][0];
        for(int i=0;i<row;i++)
        {
            for(int j=0;j<col;j++)
            {
                if(i==0&&j==0) {cout<<dp[i][j]<<"   ";continue;}
                int x=INT_MAX,y=INT_MAX;
                if(i>0) x=dp[i-1][j];
                if(j>0) y=dp[i][j-1];
                dp[i][j]=min(x,y)+grid[i][j];
            }
        }
        return dp[row-1][col-1];
    }
};
```
***************************************
 很典型的一道动态规划题。我们定义一个与给定数组相同大小的数组dp，其中的每个元素都代表到达此处的最小和。由于只能向下或向右移动，所以我们只要在*dp[i-1][j]*和*dp[i][j-1]*当中选一个即可，**不过要注意边界**。