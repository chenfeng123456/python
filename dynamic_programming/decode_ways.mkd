# Decode Ways
## Description:
```
 A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26

Given an encoded message containing digits, determine the total number of ways to decode it.
```
### For example:
```
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2. 
```
```cpp
class Solution {
public:
    int numDecodings(string s) {
        if(s.length()==0||s[0]=='0') return 0;
        if(s.length()==1) return 1;
        vector<int> dp(s.length(),0);
        dp[0]=1;
        if(s[1]=='0') 
        {
            if(s[0]=='1'||s[0]=='2') dp[1]=dp[0];
            else return 0;
        }
        else dp[1]=((s[0]-'0')*10+(s[1]-'0'))>26?1:2;
        for(int i=2;i<s.length();i++)
        {
            if(s[i]=='0')
            {
                if(s[i-1]=='0') return 0;
                else if(s[i-1]=='1'||s[i-1]=='2') 
                {                  
                    if(s[i-2]!='0') 
                    {
                        if(s[i-2]=='1'||s[i-2]=='2') dp[i]=dp[i-2];
                        else dp[i]=dp[i-1];
                    }
                    else dp[i]=dp[i-1];
                }
                else return 0;
            }
            else
            {
                dp[i]=((s[i-1]-'0')*10+(s[i]-'0'))>26||s[i-1]=='0'?dp[i-1]:(dp[i-1]+dp[i-2]);
            }
            //cout<<"dp["<<i<<"]="<<dp[i]<<"   ";
        }
        return dp[s.length()-1];
    }
};
```
********************************
我做这道题主要是找规律：

1. 如果s[i]、s[i-1]均不为0，则：
    
    1. 如果s[i-1]与s[i]连在一起小于26，dp[i]=dp[i-1]+dp[i-2];
    2. 如果s[i-1]与s[i]连在一起大于26，dp[i]=dp[i-1]
    
2. 如果s[i]=0，若s[i-1]小于2，则:

    1. 若s[i-1]=0，则直接返回0；
    2. 若s[i-1]不为0，那么：
        
        1. 如果s[i-2]为1或2，则dp[i]=dp[i-2];
        2. 否则，dp[i]=dp[i-1];

3. 如果s[i]=0，s[i-1]大于2，直接返回0；
4. 如果s[i]不为0，s[i-1]=0，则dp[i]=dp[i-1].

根据以上规律写出代码即可。