# Out of Boundary Paths
## Description:
```
There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.
```
### Example 1:
```
Input:m = 2, n = 2, N = 2, i = 0, j = 0
Output: 6
Explanation:
```
### Example 2:
```
Input:m = 1, n = 3, N = 3, i = 0, j = 1
Output: 12
Explanation:
```
### Note:

   1. Once you move the ball out of boundary, you cannot move it back.
   2. The length and height of the grid is in range [1,50].
   3. N is in range [0,50].
```cpp
class Solution {
public:
    long int p=pow(10,9)+7;
    int findPaths(int m, int n, int N, int i, int j) {
        vector<vector<vector<int>>> dp(N+1,vector<vector<int>>(m,vector<int>(n,0)));
        for(int k=1;k<=N;k++)
        {
            for(int x=0;x<m;x++)
            {
                for(int y=0;y<n;y++)
                {
                    long int up=(x==0)?1:dp[k-1][x-1][y];
                    long int down=(x==m-1)?1:dp[k-1][x+1][y];
                    long int left=(y==0)?1:dp[k-1][x][y-1];
                    long int right=(y==n-1)?1:dp[k-1][x][y+1];
                    dp[k][x][y]=(up+down+left+right)%p;
                }
            }
        }
        return dp[N][i][j];
    }
};
```
**************************************
- [思路来源](https://www.cnblogs.com/grandyang/p/6927921.html)

对于这道题显然不能用递归来做，虽然我还是试了试……

用动态规划只要给数组的下标赋予了合适的意义思路就会很明确。这道题中数组的三个下标分别表示还剩多少次可以移动，以及此时球的两个坐标。到这一步我们就能很容易地想到每一个元素的值等于它上下左右四个元素在次数少一时的和。

0次时当然为0。1次时除了边缘外也全都为0。2次相当于“边缘”往里缩了一圈，三次及以后类似。如果到了再也不能收缩以后还有多余的次数，就说明这时一定会有“冤枉路”。此时的路径就不一定是最短的了。

当然，刚刚这些与本题并没有多大联系，只是我在看懂这个算法时的一点额外思考罢了。