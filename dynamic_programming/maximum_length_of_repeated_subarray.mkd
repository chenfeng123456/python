# 718. Maximum Length of Repeated Subarray
## Description:
```
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
```
### Example 1:
```
Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].
```
### Note:

   1. 1 <= len(A), len(B) <= 1000
   2. 0 <= A[i], B[i] < 100

```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp(A.size(),vector<int>(B.size(),0));
        int len=0;
        for(int i=0;i<A.size();i++)
            dp[0][i]=(B[i]==A[0]?1:0);
        for(int i=0;i<B.size();i++)
            dp[i][0]=(A[i]==B[0]?1:0);
        for(int i=1;i<A.size();i++)
        {
            for(int j=1;j<B.size();j++)
            {
                if(A[i]!=B[j]) dp[i][j]=0;
                else dp[i][j]=dp[i-1][j-1]+1;
                len=max(len,dp[i][j]);
            }
        }
        return len;
    }
};
```
*****************************************
好久没做动态规划的题了，有点手生。

这道题我们维护一个二维数组，其下标i、j表示以A[i]和B[j]为结尾的共同子数组长度。给下标确定了合适的意义，递推就好说了：
>>- 若i=0,则比较B[j]是否等于A[0],若是，则dp[0][j]=1,否则为0；j=0时情况类似；
>>- 若A[i]!=B[j]，根据我们的规定，显然dp[i][j]=0;
>>- 若A[i]==B[j],则dp[i][j]=dp[i-1][j-1]+1;11