#Counting Bits
##Description:
```
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.
```

###Example:
```
For num = 5 you should return [0,1,1,2,1,2].
```
###Follow up:

   - It is very easy to come up with a solution with run time **O(n*sizeof(integer))**. But can you do it in linear time **O(n)** /possibly in a single pass?
   - Space complexity should be **O(n)**.
   - Can you do it like a boss? Do it without using any builtin function like **__builtin_popcount** in c++ or in any other language.
```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> answer(num+1,0);
        if(num==0) return answer;
        answer[0]=0;
        answer[1]=1;
        if(num==1) return answer;
        for(int i=2;i<num+1;i++)
        {
            if(i%2==0) answer[i]=answer[i/2];
            else answer[i]=answer[i-1]+1;
        }
        return answer;
    }
};
```
这道题最重要的是找规律。我们先写几个数看看：

|十进制|二进制|个数|
|----|-------|-----|
|0    |0000 |   0|
|1    |0001 |   1|
|2    |0010 |   1|
|3    |0011 |   2|
|4    |0100 |   1||
|5    |0101 |   2|
|6    |0110 |   2|
|7    |0111 |   3|
|8    |1000 |   1|
|9    |1001 |   2|
|10   |1010 |   2|
|11   |1011 |   3|
|12   |1100 |   2|
|13   |1101 |   3|
|14   |1110 |   3|
|15   |1111 |   4|

我们发现，若一个数为偶数，则其1的个数等于它除以2后1的个数；若为奇数，则其1的个数等于它上一个数1的个数加一。如此我们就能很轻松地写出递推关系式了。

当然，还有很多其他[更巧妙的方法](https://www.cnblogs.com/grandyang/p/5294255.html)，这里就不一一列举了。