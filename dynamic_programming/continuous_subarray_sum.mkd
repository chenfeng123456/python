# Continuous Subarray Sum
## Description:
```
 Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.
```
### Example 1:
```
Input: [23, 2, 4, 6, 7],  k=6
Output: True
Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
```
### Example 2:
```
Input: [23, 2, 6, 4, 7],  k=6
Output: True
Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
```
### Note:

   1. The length of the array won't exceed 10,000.
   2. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.

```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        if(nums.size()==0) return false;
        int len=nums.size();
        int dp=0;
        for(int i=len-2;i>=0;i--)
        {
            dp=nums[i];
            for(int j=i+1;j<len;j++)
            {
                dp=dp+nums[j];
                if(k==0) 
                {
                    if(dp==0) return true;
                }
                else if(dp%k==0) return true;
            }
        }
        return false;
    }
};
```
***********************************
最开始的想法是定义一个二维数组dp，则dp[i][j]表示下标从i到j的所有数的和。故有：

- dp[i][j]=dp[i][j-1];

但结果是Memory Error。后来仔细一想，其实每次我们都只用到了数组中的前一个元素，只需要一个变量就可以了。

> **另外要注意以下k=0的情况，否则dp%0会造成runtime error**。
另外还有[更巧妙的算法](http://blog.csdn.net/u014593748/article/details/70182807)，不过要使用哈希表，这块我还不懂，不过大体的思路还是很清除的。 