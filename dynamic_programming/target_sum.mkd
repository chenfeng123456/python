# Target Sum
## Description:
```
 You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.
```
### Example 1:
```
Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```
### Note:

   1. The length of the given array is positive and will not exceed 20.
   2. The sum of elements in the given array will not exceed 1000.
   3. Your output answer is guaranteed to be fitted in a 32-bit integer.
   
```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        if (nums.empty())
            return 0;
        
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums[i];
        
        if (S > sum)
            return 0;
        
        vector<vector<int>> dp(nums.size(), vector<int>(2 * sum + 1, 0));
        
        for (int i = 0; i < sum; i++)
        {
            if (-nums[0] == i - sum)
                dp[0][i] = 1;
        }
        if (nums[0] == 0)
            dp[0][sum] = 2; // +0 and -0
        for (int i = sum + 1; i < 2 * sum + 1; i++)
        {
            if (nums[0] == i - sum)
                dp[0][i] = 1;
        }
        
        for (int i = 1; i < nums.size(); i++) // i -> index of nums
        {
            for (int j = 0; j < 2 * sum + 1; j++) // j -> target, j = real-target + sum
            {
                if (j - nums[i] >= 0)
                    dp[i][j] += dp[i - 1][j - nums[i]];
                if (j + nums[i] < 2 * sum + 1)
                    dp[i][j] += dp[i - 1][j + nums[i]];
            }
        }
        
        /*
        for (int i = 0; i < nums.size(); i++)
        {
            for (int j = 0; j < 2 * sum + 1; j++)
                cout << left << setw(5) << dp[i][j] << " ";
            cout << endl;
        }
        */
        
        return dp[nums.size()-1][S + sum];
    }
};
```
   
   
**********************************************
这道题可以算是*背包问题*的一个变形。其具体内容可以参考崔添翼的[背包九讲](https://www.cnblogs.com/jbelial/articles/2116074.html)。

大致概括一下背包九讲中的问题，其实就是给定若干个限制，让我们求在满足这些限制的条件下求一个目标函数的最大值。

而对于本题，限制就是各个值本身或其相反数加起来等于`S`，所要求的目标就是方法数。明确了这些再参考背包问题的思路我们就能很容易地得出状态转移方程了：
```
    dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]
```

先来解释一下这个方程。i表示给定数组中的第i个数，j表示到第`i`个数为止所要等于的值。而对于`nums[i]`，如果加上它等于`j`的话，那么在加它之前的`i`个数（`i`从0开始计算）之和应该是 `j - nums[i]`；同样，如果减去它等于`j`的话，那么在减它之前的i个数之和应该为 `j + nums[i]`。

当然这里有一个bug：`S`并不一定大于0。而且就算大于0，计算的中间结果也不一定大于0。不过我们很容易发现，如果将`nums`中所有的数加起来得到`sum`，中间结果的值一定在`[-sum, sum]`中。因而这里我们将dp的列数扩展为`2 * sum + 1`。自然，`j`的含义也发生了变化：之前`j`代表的就是目标值本身，现在则变为了目标值加`sum`。不过因为是所有`j`都加上了一个相同的数，所以并不影响状态转移方程。

另外要注意的一点是，`dp`数组的第一行需要单独拿出来计算：前`sum`个目标值减去`sum`后如果有等于`-nums[0]`的，令其等于1；后`sum`个目标值减去`sum`后如果有等于`nums[0]`，也令其等于1；**如果nums[0]刚好等于0的话，我们应当令dp[0][sum]等于2，因为 +0 和 -0 都等于0**。