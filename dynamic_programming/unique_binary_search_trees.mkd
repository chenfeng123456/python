# Unique Binary Search Trees
## Description:
```
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example,
Given n = 3, there are a total of 5 unique BST's.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
```cpp
class Solution {

    private:
    vector<int> num;
    int N;
    public:
    int count(int n)
    {
        if(num[n]!=0) return num[n];
        //if(n==0) return 1;
        else
        {
            int ans=0;
            for(int i=n/2;i>0;i--)
            {
                ans+=count(i-1)*count(n-i);
            }
            if(n%2==0) ans*=2;
            else ans=ans*2+count(n/2)*count(n/2);
            num[n]=ans;
            return ans;         
        }
    }
    
    int numTrees(int n) {
        if(n==0) return 1;
        N=n;
        num.resize(n+1,0);
        num[0]=1;
        num[1]=1;
        /*int ans=0;
        for(int i=n/2;i>0;i--)
        {
            ans+=count(i-1)*count(n-i);
        }
        if(n%2==0) ans*=2;
        else ans=ans*2+count(n/2+1);*/
        count(n);
        //for(int i=0;i<=n;i++) cout<<num[i]<<"  ";
        return num[n];
    }
};
```
*************************************
*第一次自己写的代码战胜了100%。* :smile:

对于这道题，我们要认识到几点：

- n个数所能构成的二叉树的数量只与n的大小及这n个数之间的大小关系有关，而与这n个数本身的数值无关。*比如1、2、3和2、3、4能构成的二叉树种类数目是相等的。*而本题中数的大小关系都是升序，所以只与n的有关。
- 对于一个给定的n，其结果等于以从1到n中每一个数为根节点时比根节点小的数所能构成的二叉树种类数乘上比它大的数所能构成的二叉树种类数。
- 当n=0时我们不能返回0,而应返回1。因为即使有一边甚至的子树没有元素，只靠一个根节点也能组成一个二叉树。
- 为了避免重复计算，我们在类里面定义一个数组来记录已算出的结果，每个元素代表当n为其下标时，对应的结果。

由此我们得出递推关系式：
       
       以i为节点时的二叉树数量为：count（i-1）*count（n-i）
       
按以上思路写出代码即可。
